
==================== FINAL INTERFACE ====================
2018-10-11 03:55:45.951473 UTC

interface haskell-tutes-0.1.0.0-BNUJnE3XuXS5kv5h66avW4:Support [orphan module] 8022
  interface hash: a0dfd1c230e0d7ed15ca3f9165efae9c
  ABI hash: 6b3ecfab7f5884cabfcfbbb4b7abca4d
  export-list hash: e8401888e44c688b3e1eaae611def5fc
  orphan hash: b815b84cac0cf767e5cc29235f2e337d
  flag hash: bd29246931572356afdc42a66f13eebb
  sig of: Nothing
  used TH splices: False
  where
exports:
  Support.lift
module dependencies: Applicative Base Functions Functor Monad
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Control.Applicative 99577a9c463ffe4790a1d37547a345bd
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 525805ab19df5e4fe6d8de7dde9cb909
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  Applicative 6f38f2b68150346c7ad83f48e33d0f3a
  exports: 68b0a1c6874d8488a06eeaa957564063
  <*> 1dd330293e8ae472937681bc1bc72257
  Applicative 5d23c9bd84288312c6b6346bc51d2b30
import  -/  Functor 8c9db5f0e8cc075aac6808e26a659a17
  exports: 25365b16bb2390e97612c086388f5ba1
  <$> c1a54d3e0f34c5b400dffecce8353271
  Functor 317494c2b0d5fdecc98bb826bd3446ae
import  -/  Monad e2faa16d56981bf642daac0ce4482481
  exports: 6ee886d342d11e9e096b3601aecca342
  Monad f3cb113cb0f6c1fc4c78e94af96f5943
9f45d04dde6d8676635d188b7fe04f82
  $fApplicative(->) :: Applicative.Applicative ((->) t)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ t.
                  @ ((->) t)
                  (\ @ a @ b -> GHC.Base.. @ a @ b @ t)
                    `cast`
                  (Sym (Functor.N:Functor[0] <(->) t>_N))
                  (\ @ a -> GHC.Base.const @ a @ t)
                  (GHC.Base.$fApplicative(->)_$c<*> @ t) -}
827fa1d4e7add635767479d10f10d831
  $fApplicativeIO :: Applicative.Applicative GHC.Types.IO
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  GHC.Base.$fFunctorIO2
                    `cast`
                  (Trans
                       (forall (a :: <*>_N) (b :: <*>_N).
                        <a -> b>_R
                        ->_R <GHC.Types.IO a>_R
                        ->_R Sym (GHC.Types.N:IO[0] <b>_R))
                       (Sym (Functor.N:Functor[0] <GHC.Types.IO>_N)))
                  GHC.Base.$fApplicativeIO4
                    `cast`
                  (forall (a :: <*>_N). <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R))
                  (\ @ a @ b -> GHC.Base.$fApplicativeIO3 @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <GHC.Types.IO (a -> b)>_R
                   ->_R <GHC.Types.IO a>_R
                   ->_R Sym (GHC.Types.N:IO[0] <b>_R)) -}
7b89dce449d7fdaed7d06756453a673b
  $fFunctor(->) :: Functor.Functor ((->) t)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (\ @ t @ a @ b -> GHC.Base.. @ a @ b @ t)
                  `cast`
                (forall (t :: <*>_N). Sym (Functor.N:Functor[0] <(->) t>_N)) -}
69035c34f7f412a74b1d22e44286dd7f
  $fFunctorIO :: Functor.Functor GHC.Types.IO
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                GHC.Base.$fFunctorIO2
                  `cast`
                (Trans
                     (forall (a :: <*>_N) (b :: <*>_N).
                      <a -> b>_R
                      ->_R <GHC.Types.IO a>_R
                      ->_R Sym (GHC.Types.N:IO[0] <b>_R))
                     (Sym (Functor.N:Functor[0] <GHC.Types.IO>_N))) -}
64e13fbd9fa0bbcb7a8907a89ca6ff27
  $fMonad(->) :: Monad.Monad ((->) t)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ t.
                  @ ((->) t)
                  (Support.$fApplicative(->) @ t)
                  (Support.$fMonad(->)_$c=<< @ t) -}
fb795da4f86bf1a7f0e1d4c37767c3a1
  $fMonad(->)_$c=<< :: (a -> t -> b) -> (t -> a) -> t -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ t @ a @ b (f :: a -> t -> b) (x :: t -> a) ->
                 GHC.Base.$fMonad(->)_$c>>= @ t @ a @ b x f) -}
eb1f7a6949689d763ca4a46e18851a50
  $fMonadIO :: Monad.Monad GHC.Types.IO
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Types.IO
                  Support.$fApplicativeIO
                  (\ @ a @ b -> Support.$fMonadIO1 @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> GHC.Types.IO b>_R
                   ->_R <GHC.Types.IO a>_R
                   ->_R Sym (GHC.Types.N:IO[0] <b>_R)) -}
d4aa1255d25cab17a821523eca8a6574
  $fMonadIO1 ::
    (a -> GHC.Types.IO b)
    -> GHC.Types.IO a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><L,C(U(U,U))>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (f :: a -> GHC.Types.IO b) (x :: GHC.Types.IO a) ->
                 GHC.Base.$fMonadIO1 @ a @ b x f) -}
0f5f15c68201de22effbfdd1791a165a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Support.$trModule3
                   Support.$trModule1) -}
0981738810dfcf9f49125f94bb5c8ab4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Support.$trModule2) -}
7c01d60794dceed25516821fc7af14d4
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Support"#) -}
13b9198965cac2052d72c09ade697fa9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Support.$trModule4) -}
658720ebc699bf62191fa844c9acfdea
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("haskell-tutes-0.1.0.0-BNUJnE3XuXS5kv5h66avW4"#) -}
0eb39dc70859d5edd6c32c24a250fffe
  lift ::
    Applicative.Applicative f => (a -> b -> c) -> f a -> f b -> f c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),U(1*C1(C1(U)),A,1*C1(C1(U)))><L,U><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   @ c
                   ($dApplicative :: Applicative.Applicative f)
                   (eta :: a -> b -> c)
                   (eta1 :: f a)
                   (eta2 :: f b) ->
                 Applicative.<*>
                   @ f
                   $dApplicative
                   @ b
                   @ c
                   ((Applicative.$p1Applicative @ f $dApplicative)
                      `cast`
                    (Functor.N:Functor[0] <f>_N)
                      @ a
                      @ (b -> c)
                      eta
                      eta1)
                   eta2) -}
instance [safe] [orphan] Applicative.Applicative [(->)]
  = Support.$fApplicative(->)
instance [safe] [orphan] Applicative.Applicative [GHC.Types.IO]
  = Support.$fApplicativeIO
instance [safe] [orphan] Functor.Functor [(->)]
  = Support.$fFunctor(->)
instance [safe] [orphan] Functor.Functor [GHC.Types.IO]
  = Support.$fFunctorIO
instance [safe] [orphan] Monad.Monad [(->)] = Support.$fMonad(->)
instance [safe] [orphan] Monad.Monad [GHC.Types.IO]
  = Support.$fMonadIO
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

