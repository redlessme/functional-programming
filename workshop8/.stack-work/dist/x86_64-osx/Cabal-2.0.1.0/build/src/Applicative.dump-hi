
==================== FINAL INTERFACE ====================
2018-09-17 01:05:54.35081 UTC

interface haskell-tutes-0.1.0.0-7TKq6HTn4VZFi18Zn4nbmB:Applicative 8022
  interface hash: 0a1e98bf7733e84c8f3b24da346537df
  ABI hash: f2d97fdeeaa97f9c471b9e10f376203e
  export-list hash: 2fcb700f7e628d0a02110df98d07ba28
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f4578fe61ad65cb1f88a5bbe0bb412f8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Applicative.<$>
  Applicative.Applicative{Applicative.<*> Applicative.pure}
module dependencies: Base Functor
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:GHC.Err 514b3a24b22e9d7d731c2d0d02d10842
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  Base 3a2b43282c6fec09282a5d6aab507fbf
  exports: 185edd00dc52698b6b2121e95e283db0
  Id da1dbff0a4b12ef0d4478b87a53e9f80
  Id c00e45af4b5bc7d349da9f7b1addef73
  Node fe2fc5d940839f35d702b7479ec65fcf
  RoseTree 729d81f3958e6390060a769a91cf1af7
import  -/  Functor 546fb84b660a6922feaf2da53d83112c
  exports: 9a1925fbfbf3fc24ad7109f9188c3d64
  Functor 556ba3c28be1c59964328688e146ea8e
fixities infixl 4 <*>
3460dfa1f5af04523439ffbdb93d9019
  $fApplicativeId :: Applicative.Applicative Base.Id
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Base.Id
                  Functor.$fFunctorId_$c<$>
                    `cast`
                  (Sym (Functor.N:Functor[0] <Base.Id>_N))
                  Base.Id
                  Applicative.$fApplicativeId_$c<*> -}
b2d56ebd96c3785899d0c0ee3941af95
  $fApplicativeId_$c<*> :: Base.Id (a -> b) -> Base.Id a -> Base.Id b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(1*C1(U))><S,1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ds :: Base.Id (a -> b)) (ds1 :: Base.Id a) ->
                 case ds of wild { Base.Id f ->
                 case ds1 of wild1 { Base.Id a1 -> Base.Id @ b (f a1) } }) -}
3460dfa1f5af04523439ffbdb93d9019
  $fApplicativeMaybe :: Applicative.Applicative GHC.Base.Maybe
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Base.Maybe
                  Functor.$fFunctorMaybe_$c<$>
                    `cast`
                  (Sym (Functor.N:Functor[0] <GHC.Base.Maybe>_N))
                  GHC.Base.Just
                  Applicative.$fApplicativeMaybe_$c<*> -}
197d984cdc0e53e8a2beeb21bc775ff6
  $fApplicativeMaybe_$c<*> ::
    GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (ds :: GHC.Base.Maybe (a -> b))
                   (ds1 :: GHC.Base.Maybe a) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ b
                   GHC.Base.Just ipv
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ b
                        GHC.Base.Just ipv1 -> GHC.Base.Just @ b (ipv ipv1) } }) -}
3460dfa1f5af04523439ffbdb93d9019
  $fApplicativeRoseTree :: Applicative.Applicative Base.RoseTree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Base.RoseTree
                  Functor.$fFunctorRoseTree_$c<$>
                    `cast`
                  (Sym (Functor.N:Functor[0] <Base.RoseTree>_N))
                  Applicative.$fApplicativeRoseTree_$cpure
                  Applicative.$fApplicativeRoseTree_$c<*> -}
d69ca82bc927ca6e4100d8b3e742fa0c
  $fApplicativeRoseTree_$c<*> ::
    Base.RoseTree (a -> b) -> Base.RoseTree a -> Base.RoseTree b
  {- Strictness: x -}
21615d88e26954a86cc944f2a2744345
  $fApplicativeRoseTree_$cpure :: a -> Base.RoseTree a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (a1 :: a) ->
                 Base.Node @ a a1 (GHC.Types.[] @ (Base.RoseTree a))) -}
3460dfa1f5af04523439ffbdb93d9019
  $fApplicative[] :: Applicative.Applicative []
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ []
                  Functor.$fFunctor[]_$c<$>
                    `cast`
                  (Sym (Functor.N:Functor[0] <[]>_N))
                  Applicative.$fApplicative[]_$cpure
                  Applicative.$fApplicative[]_$c<*> -}
9c418e6d41056ef96c3662c3ddb45db1
  $fApplicative[]_$c<*> :: [a -> b] -> [a] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a @ b (fs :: [a -> b]) (xs :: [a]) ->
                 letrec {
                   go :: [a -> b] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a -> b]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ b
                       : y ys
                       -> let {
                            z :: [b] = go ys
                          } in
                          letrec {
                            go1 :: [a] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [a]) ->
                              case ds1 of wild1 {
                                [] -> z : y1 ys1 -> GHC.Types.: @ b (y y1) (go1 ys1) }
                          } in
                          go1 xs }
                 } in
                 go fs) -}
0411117bcccb2d89b263824cfaef542d
  $fApplicative[]_$cpure :: a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (a1 :: a) -> GHC.Types.: @ a a1 (GHC.Types.[] @ a)) -}
d6436192f4079ff467bed02230cee14c
  $tcApplicative :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10913612356711964394##
                   9627071912785485719##
                   Applicative.$trModule
                   Applicative.$tcApplicative2
                   0#
                   Applicative.$tcApplicative1) -}
008e7e7304a3dc81f41dedc1922aaf9d
  $tcApplicative1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7ea05d77cd0a8f8cfe020b4119949571
  $tcApplicative2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Applicative.$tcApplicative3) -}
7953baa352c6722532a84393f5ada4b1
  $tcApplicative3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Applicative"#) -}
3dc0b2e31f4d7bc8c020c9103b77d2ee
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Applicative.$trModule1
                   Applicative.$tcApplicative2) -}
37a1f35395d7198d579a0726497eb084
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Applicative.$trModule2) -}
c571f15dacf6ff573834004c0e52e5e7
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("haskell-tutes-0.1.0.0-7TKq6HTn4VZFi18Zn4nbmB"#) -}
2cfe2df6c2f8556428934193adaf5f32
  (<$>) :: Applicative.Applicative f => (a -> b) -> f a -> f b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),U(A,1*C1(U),1*C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   ($dApplicative :: Applicative.Applicative f)
                   (f1 :: a -> b)
                   (a1 :: f a) ->
                 Applicative.<*>
                   @ f
                   $dApplicative
                   @ a
                   @ b
                   (Applicative.pure @ f $dApplicative @ (a -> b) f1)
                   a1) -}
3460dfa1f5af04523439ffbdb93d9019
  class Functor.Functor f => Applicative (f :: * -> *) where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    {-# MINIMAL pure, (<*>) #-}
instance [safe] Applicative.Applicative [Base.Id]
  = Applicative.$fApplicativeId
instance [safe] Applicative.Applicative [GHC.Base.Maybe]
  = Applicative.$fApplicativeMaybe
instance [safe] Applicative.Applicative [Base.RoseTree]
  = Applicative.$fApplicativeRoseTree
instance [safe] Applicative.Applicative [[]]
  = Applicative.$fApplicative[]
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

